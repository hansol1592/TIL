# Interview List

## 개발상식

- 객체 지향 프로그래밍이란 무엇인가?

  - 관리체계, 책장, 데이터, 코드, 복잡도, 정리
  - "객체"라는 Box 에 복잡한 대상(함수, 변수 등)을 잘 정리해 두는 것.
  - 복잡한 것을 함수에 담아서 정리(function Do() { ...복잡 } -> Do() 로 단순화) -> 함수가 다시 복잡(Do1(), Do2(), Do3()) -> 이것을 다시 객체에 정리 -> toy = { Do1(), Do2(), Do3(), ... } -> toy.Do1(), toy.Do2(), toy.Do3()
  - 재사용성이 높아진다. 자주 사용되는 로직을 잘 정리해두면(라이브러리로 만드는 등의 방식으로) 계속 사용할 수 있으며 신뢰성을 확보할 수 있다.
  - 따라서, 디버깅, 유지보수, 데이터 모델링시 객체와 매핑하는 것에 좋다.
  - 역할에 따라서 객체로 나눠서 정리하고, 각 객체에 더해서 가져야 할 특성을 상속을 통해 확장해 추가할 수 있다.
  - 문제
    - 객체가 상태를 갖게 됨.
    - 변수가 존재하고 이 변수를 통해 객체가 예측할 수 없는 상태를 갖게 되어 버그 발생 -> 함수형 프로그래밍 패러디암이 주목받는 이유.
  - 설계 원칙
    - 단일 책임 원칙, 개방-폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙, 의존 역전 원칙

- 함수형 프로그래밍이란?

  - 순수함수, 인풋-아웃풋, 주어지는 역할을 간섭, 참조 없이 수행 -> 결과값에 대한 신뢰 가능,
    독립성, 변수의 부서적인 값 변경등의 오류를 원천 배제
  - 순수함수 - 순수하게 정해진 역할을 수행하는 함수.
  - 선언형. 함수를 값으로 이해, 인자로 사용가능
    var say_it = function(given) { console.log(given) }
    const say_it = (given) => console.log(given)
  - imuutable, 일급 객체, 순수 함수.
  - 리액트의 함수형 컴포넌트를 생각하면 이해가 쉽다.
    예를 들어 어떤 string 이 들어왔을 때 h1 tag 로 감싸서 출력하는 컴포넌트를 작성했다면,
    여기서 이 컴포넌트는 string 이 무엇인지 알 지 못한다.
    그렇지만 정확히 그 string 을 h1 tag 로 감싸서 출력한다.
    이렇게 순수함수의 역할을 하고, 이러한 컴포넌트를 엮어서 프로그래밍을 구성해가는 것을
    함수형 프로그래밍이라고 이해할 수 있지 않을까 생각한다.

- RESTful API 란 무엇인가?

  - API - application programming interface
    - 소프트웨어가 통신하는 interface
  - RESTful API - http 환경에서 api 를 작성하는 형식. 약속.
  - 리소스는 uri 로 표현하며, 리소스가 가리키는 것은 명사로 명시적으로, 분명하게 써야함.
  - get, post, put, patch, delete 등을 명확하게 써야함.

- TDD 란 무엇이며 어떠한 장점이 있는가?

  - 테스트 코드를 작성하고, 그 테스트를 통과하는 코드를 작성하는 것.
  - 신뢰도를 높일 수 있고, 리팩토링시에 보다 보장되는 환경에서 할 수 있음.

- MVC 패턴이란 무엇인가?

  ### web browser -> web server -> controller(servlet) -> model(with database, value object) -> cotroller -> view(jsp) -> controller -> web serber -> web browser

  - MVC 각 컴포넌트의 역할

    - CONTROLLER(컨트롤러)
      - 일종의 조정자
      - 클라이언트의 요청을 받았을 때, 그 요청에 대해 실제 업무를 수행하는 모델 컴포넌트를 호출.
      - 클라이언트가 보낸 데이터가 있다면, 모델에 전달하기 쉽게 데이터 가공.
      - 모델이 업무를 마치면 그 결과를 뷰에게 전달.
    - MODEL(모델)
      - 컨트롤러가 호출할 때, 요청에 맞는 역할을 수행한다.
      - 비즈니스 로직을 구현하는 영역으로, 응용프로그램에서 데이터를 처리하는 부분.
      - 비즈니스 로직이란 업무에 필요한 데이터 처리를 수행하는 응용프로그램의 일부.
      - DB에 연결하고, 데이터를 추출하거나 저장, 삭제, 업데이트, 변환 등의 작업 수행.
      - 상태의 변화가 있을 때 컨트롤러와 뷰에 통보해 후속 조치 명령을 받을 수 있게 한다.
    - VIEW(뷰)

      - 컨트롤러로부터 받은 모델의 결과값을 가지고 사용자에게 출력할 화면을 만드는 일을 한다.
      - 만들어진 화면을 웹브라우저에 전송하여 웹브라우저가 출력하게 하는 것이다.
      - 화면에 표시되는 부분으로 추출한 데이터나 일반적인 텍스트 데이터를 표시하거나
        입력폼 또는 사용자와의 상호작용을 위한 인터페이스를 표시하는 영역이다.

    - 리액트에서라면 controller 는 app 또는 index 파일,
      model 은 로직을 담당하는 container 파일,
      view 는 presenter 라고 이해할 수도 있지 않을까.

* Git 과 GitHub 에 대해서

  - Git 은 버전관리를 위한 소프트웨어
  - GitHub 는 Git 으로 저장돼서 원격전송된 내역들이 저장되는 공간을 제공하는 서비스.

## 자료구조

- Array vs LinkedLlist

  - Array 는 순서 그대로 저장한다. 따라서 index 를 통해 해당 원소에 빠르게 접근 할 수 있다.
    그렇지만 삭제, 삽입 시에는 이 순서에 균열이 생기기 때문에 그 균열을 다시 조정해야하는 비용이 발생한다.
  - LinkedList 는 자료를 연결하는 지점을 만들어서 저장한다. 따라서 삭제와 삽입을 쉽게 할 수 있다.
    하지만 해당 위치, 원소를 탐색하는 비용이 높다.

- Stack and Queue (선형 구조)

  - Stack 은 나중에 들어간게 먼저 나온다. 차곡차곡 쌓여서 가장 위에 있는 것이 출력됨. Last in First out
  - Queue 는 먼저 들어간게 먼저 나온다. 먼저 들어간게 가장 앞에 있다가 가장 먼저 출력됨. First in First out

- Tree (비 선형 구조)
  - 계층적 관계(Hierarchical Relationship)를 표현하는 자료구조.
  - Node, Edge, Root Node, Terminal Node, Internal Node
  - Binary Tree
  - Full Binary Tree
  - Complete Binary Tree
  - BST (Binary Search Tree)
    - 효율적인 탐색을 위한 저장방법
    - binary search 와 linked list 를 결합한 자료구조의 일종이다.
      이진 탐색의 효율적인 탐색 능력을 유지하면서도, 빈번한 자료 입력과 삭제가 가능하게 하기 위함.
- Binary Heap
  - 자료구조를 효율적으로 관리하는 방법?
  - Red Black Tree - 정의 - 특징 - 삽입 - 삭제
- Hash Table
  - hash function
  - Resolve Collision
    - Open Addressing
    - Separate Chaining
  - Resize
- Graph
  - Graph 용어 정리
  - Graph 구현
  - Graph 탐색
  - Minimum Spanning Tree
    - Kruskal algorithm
    - Prim algorithm

## 네트워크

- GET, POST 방식의 차이점

  - GET

    - GET 방식은 요청하는 데이터가 HTTP Request Message의 Header 부분의 url 에 담겨서 전송된다. 때문에 url 상에 ? 뒤에 데이터가 붙어 request 를 보내게 되는 것이다. 이러한 방식은 url 이라는 공간에 담겨가기 때문에 전송할 수 있는 데이터의 크기가 제한적이다. 또 보안이 필요한 데이터에 대해서는 데이터가 그대로 url 에 노출되므로 GET방식은 적절하지 않다. (ex. password)

  - POST

    - POST 방식의 request 는 HTTP Message의 Body 부분에 데이터가 담겨서 전송된다. 때문에 바이너리 데이터를 요청하는 경우 POST 방식으로 보내야 하는 것처럼 데이터 크기가 GET 방식보다 크고 보안면에서 낫다.(하지만 보안적인 측면에서는 암호화를 하지 않는 이상 고만고만하다.)

  - 우선 GET 은 가져오는 것이다. 서버에서 어떤 데이터를 가져와서 보여준다거나 하는 용도이지 서버의 값이나 상태 등을 변경하지 않는다. SELECT 적인 성향을 갖고 있다고 볼 수 있는 것이다. 반면에 POST 는 서버의 값이나 상태를 변경하기 위해서 또는 추가하기 위해서 사용된다.
    부수적인 차이점을 좀 더 살펴보자면 GET 방식의 요청은 브라우저에서 Caching 할 수 있다. 때문에 POST 방식으로 요청해야 할 것을 보내는 데이터의 크기가 작고 보안적인 문제가 없다는 이유로 GET 방식으로 요청한다면 기존에 caching 되었던 데이터가 응답될 가능성이 존재한다. 때문에 목적에 맞는 기술을 사용해야 하는 것이다.

- TCP 3-way-handshake
- UDP 와 TCP 의 차이점

  - UDP
    - UDP(User Datagram Protocol, 사용자 데이터그램 프로토콜)는 비연결형 프로토콜 이다. IP 데이터그램을 캡슐화하여 보내는 방법과 연결 설정을 하지 않고 보내는 방법을 제공한다. UDP는 흐름제어, 오류제어 또는 손상된 세그먼트의 수신에 대한 재전송을 하지 않는다. 이 모두가 사용자 프로세스의 몫이다. UDP가 행하는 것은 포트들을 사용하여 IP 프로토콜에 인터페이스를 제공하는 것이다.
  - TCP
    - 대부분의 인터넷 응용 분야들은 신뢰성 과 순차적인 전달 을 필요로 한다. UDP 로는 이를 만족시킬 수 없으므로 다른 프로토콜이 필요하여 탄생한 것이 TCP이다. TCP(Transmission Control Protocol, 전송제어 프로토콜)는 신뢰성이 없는 인터넷을 통해 종단간에 신뢰성 있는 바이트 스트림을 전송 하도록 특별히 설계되었다. TCP 서비스는 송신자와 수신자 모두가 소켓이라고 부르는 종단점을 생성함으로써 이루어진다. TCP 에서 연결 설정 (connection establishment)는 3-way-handshake를 통해 행해진다.
      모든 TCP 연결은 전이중(full-duplex), 점대점(point to point)방식이다. 전이중이란 전송이 양방향으로 동시에 일어날 수 있음을 의미하며 점대점이란 각 연결이 정확히 2 개의 종단점을 가지고 있음을 의미한다. TCP 는 멀티캐스팅이나 브로드캐스팅을 지원하지 않는다.

- HTTP 와 HTTPS 의 차이점

  - HTTP 는 데이터를 주고 받기 위한 통신 프로토콜.
    - 먼저 클라이언트에 접속 -> 클라이언트가 요청 -> 서버가 응답
    - stateless 라서 한번 왔다갔다하면 연결이 끊겨서 불특정 다수를 향한 서비스에 적합.
  - HTTP 의 문제점들

    - 보안
      - 평문 통신 - 도청 가능
      - 통신 상대 확인 하지 않음 - 위장 가능
      - 완정성을 증명할 수 없음 - 변조 가능
    - 해결 방법
      - 통신 자체를 암호화
        SSL(Secure Socket Layer) or TLS(Transport Layer Security) 라는 다른 프로토콜을 조합함으로써
        HTTP 의 통신 내용을 암호화 할 수 있다. SSL 을 조합한 HTTP 를 HTTPS(HTTP Secure) or HTTP over SSL 이라고 한다.
      - 콘텐츠를 암호화
        HTTP 메시지에 포함되는 콘텐츠만 암호화. 암호화해서 전송하면 받는 측에서는 그 암호를 해독하여 출력하는 처리가 필요.

  - HTTPS
    HTTP 에 암호화와 인증, 그리고 완정성 보호를 더한 HTTPS
    - HTTP 는 원래 TCP 와 직접 통신했지만, HTTPS 에서 HTTP 는 SSL 과 통신하고 SSL 이 TCP 와 통신 하게 된다. SSL 을 사용한 HTTPS 는 암호화와 증명서, 안전성 보호를 이용할 수 있게 된다.
    - 모든 웹 페이지에서 HTTPS 를 사용하지 않는 이유
      평문 통신에 비해서 암호화 통신은 CPU 나 메모리 등 리소스가 많이 필요하다. 그렇기 때문에 통신할 때마다 암호화를 하면 서버 한대당 처리할 수 있는 리퀘스트의 수가 줄어든다. 그렇기 때문에 민감한 정보를 다룰 때만 HTTPS 에 의한 암호화 통신을 사용한다.

- DNS round robin 방식
- 웹 통신의 큰 흐름

## 운영체제

- 프로세스와 스레드의 차이
- 스케줄러의 종류
  - 장기 스케줄러
  - 단기 스케줄러
  - 중기 스케줄러
- CPU 스케줄러
  - FCFS
  - SJF
  - SRT
  - Priority scheduling
  - RR
- 동기와 비동기의 차이
- 멀티스레드
  - 장점과 단점
- 프로세스 동기화
  - Critical Section
  - 해결책
- 메모리 관리 전략
  - 메모리 관리 배경
  - Paging
  - Segmentation
- 가상 메모리
  - 배경
  - 가상 메모리가 하는 일
  - Demand Paging(요구 페이징)
  - 페이지 교체 알고리즘
- 캐시의 지역성
  - Locality
  - Caching line

## 데이터베이스

- 데이터 베이스
  - 데이터 베이스를 사용하는 이유
  - 데이터베이스 성능
- index
  - index 란 무엇인가
  - index 의 자료구조
  - Primary index vs Secondary index
  - Composite index
  - Index 의 성능과 고려해야할 사항
- 정규화에 대해서
  - 정규화 탄생 배경
  - 정규화란 무엇인가
  - 정규화의 종류
  - 정규화의 장단점
- Transaction
  - 트랜잭션(Transaction) 이란 무엇인가?
  - 트랜잭션과 Lock
  - 트랜잭션의 특성
  - 트랜잭션의 상태
  - 트랜잭션을 사용할 때 주의할 점
- Statement vs PrepareStatement
- NoSQL
  - 정의
  - CAP 이론
    - 일관선
    - 가용성
    - 네트워크 분할 허용성
  - 저장방식에 따른 분류
    --Value Model
    - Document Model
    - Column Model

## 디자인 패턴

- Singleton

## 알고리즘

## 프론트엔드

- 브라우저의 동작 원리

  - Browser

    - 브라우저의 주요 기능은 사용자가 선택한 자원을 서버에 요청하고 브라우저에 표시하는 것이다. 자원은 보통 HTML 문서지만 PDF나 이미지 또는 다른 형태일 수 있다. 자원의 주소는 URI(Uniform Resource Identifier)에 의해 정해진다.

  - 요약
    HTML 마크업을 처리하고 DOM 트리를 빌드한다. ("무엇을" 그릴지 결정한다.)
    CSS 마크업을 처리하고 CSSOM 트리를 빌드한다. ("어떻게" 그릴지 결정한다.)
    DOM 및 CSSOM 을 결합하여 렌더링 트리를 형성한다. ("화면에 그려질 것만" 결정)
    렌더링 트리에서 레이아웃을 실행하여 각 노드의 기하학적 형태를 계산한다. ("Box-Model" 을 생성한다.)
    개별 노드를 화면에 페인트한다.(or 래스터화)

  - 흐름

    - html -> html parser -> dom tree
    - css -> css parser -> 스타일 규칙
    - 둘을 합해서 렌더 트리 구성.
    - 그리기
    - 표시

  - DOM
    "파싱 트리"는 DOM 요소와 속성 노드의 트리로서 출력 트리가 된다. DOM은 문서 객체 모델(Document Object Model)의 준말이다. 이것은 HTML 문서의 객체 표현이고 외부를 향하는 자바스크립트와 같은 HTML 요소의 연결 지점이다. 트리의 최상위 객체는 문서이다.

- Document Object Model(작성중)
  - Event bubbling and Capturing
  - Event delegation
- CORS
  - 다른 도메인으로부터 리소스가 요청될 경우 해당 리소스는 cross-origin HTTP 요청 에 의해 요청된다. 하지만 대부분의 브라우저들은 보안 상의 이유로 스크립트에서의 cross-origin HTTP 요청을 제한한다. 이것을 Same-Origin-Policy(동일 근원 정책)이라고 한다. 요청을 보내기 위해서는 요청을 보내고자 하는 대상과 프로토콜도 같아야 하고, 포트도 같아야 함을 의미한다.(이 때, 서브 도메인 네임은 상관없다.)
  - CORS는
    타 도메인 간에 자원을 공유할 수 있게 해주는 것이다. Cross-Origin Resource Sharing 표준은 웹 브라우저가 사용하는 정보를 읽을 수 있도록 허가된 출처 집합을 서버에게 알려주도록 허용하는 특정 HTTP 헤더를 추가함으로써 동작한다.
- 크로스 브라우징

  - 웹 표준에 따라 개발을 하여 서로 다른 OS 또는 플랫폼에 대응하는 것을 말한다. 즉, 브라우저의 렌더링 엔진이 다른 경우에 인터넷이 이상없이 구현되도록 하는 기술이다.
  - 공통요소로 웹 페이지를 제작하여 다른 환경에서도 동작하도록 하는 것.

- 웹 성능과 관련된 Issues

- client side rendering - server sider rendering

  - client side rendering 은 client 에서 많은 일을 함.<br />
    서버에서는 json 을 보내주는 역할을 하고, html 을 그리는 등의 역할을 클라이언트에서 담당하게 됨.<br/>
    -> client 무거워짐.<br />
    -> view 만 하자는 react 등장.

  - CSR

  - 필요한 부분만 읽으면 됨 -> 빠른 인터렉션.
  - 일관성 있는 코드.
  - 페이지를 읽는 시간, 자바스크립트를 읽는 시간,<br />
    자바스크립트가 페이지를 그리는 시간이 다 필요.<br />
    -> 초기 구동 속도 느려짐(그 이후에는 빠른 인터렉션)

  - 문제
    - 검색엔진 최적화 문제
      - 웹 크롤러, 봇들이 자바스크립트를 못읽음.<br />
        -> html 에서만 정보를 수집하게 되어 클라이언트 사이드 렌더링 되는 페이지를 빈 페이지로 인식.
    - 보안 문제
      - 쿠키말고는 사용자 정보를 저장할 공간 없음.
        - ssr 에서는 서버측에서 세션등으로 관리.

- SSR

  - CSR 의 반대를 생각하면 쉽다.
  - 컨텐츠를 처음 접하는 시점을 당길 수 있다.
  - 서버따로, 클라이언트따로 작성하던 코드 통합 가능.
  - SEO 도 OK

  - 인터렉션 문제
    - 매번 서버에 리퀘스트 요청을 통해야 하기 때문.
    - DOM 조작에서도 요청 과정과 탐색 비용으로 애먹고 있다.
    - REACT 가 많은 해결책을 제시했지만 두고 봐야함.

* 정리
  - CSR
    - 빠른 인터렉션과 일관된 코드
    - 자바스크립트를 읽는 시간이 필요해 초기 구동 느림.
    - 웹 크롤러, 봇이 자바스크립트를 못읽어서 SEO 문제.
    - 보안문제. 서버가 아닌 클라이언트에서 해야하고, 그러려면 쿠키로 해야함.
  - SSR
    - 서버가 많은 일.
    - 컨텐츠 접하는 시점 당길 수 있음.
    - 서버, 클라이언트 코드 통합.
    - SEO -> OK
    - 인터렉션 -> 매번 request 해야하고, DOM 조작에도 요청과정과 탐색비용이 듬.

- CSS Methodology
- normalize.css vs reset.css

  - nomalize

    - 브라우저간 일관된 스타일링을 목표로 한다.

  - reset
    - 기본 제공되는 브라우저 스타일을 전부 제거.
